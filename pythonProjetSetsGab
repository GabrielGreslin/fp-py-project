__author__ = 'Gabriel'

'''
This is a python project built only with :
map(f,l) apply f on each element of l
reduce(f,l,[init]) apply f on the first two elements then on the result and the third and so on, return on value
filter(f,l) return a list with the element of l which are satisfied f
        f a function to Boolean

        AND USING SETS instead of list
'''

from functools import reduce  # required to access reduce
from functools import partial  # required to create partial function

#UNCOMMENT FOR EXECUTION TIME TEST
'''
import time
import os
import sys

init=sys.stdout
f = open(os.devnull, 'w')
sys.stdout = f
start = time.time()
'''

# test elements
s = set([0, 1, 2, 3, 5, -3, 1, 7, 4, 10])
p = lambda x: bool(x % 2)  # is odd
f = lambda x: x / 2

#########################
def loop(p, f, x):
    if p(x):
        return x
    else:
        return loop(p, f, f(x))


print(loop(p, f, 10))
print(loop(p, f, 2 * 4 * 3 * 5))

#########################
def exists(p, s):
    f = lambda x, li: x or p(li)
    return reduce(f, s, False)


print(exists(p, s))
print(exists(p, set([0, 2, 4, 6, 8, 10])))

#########################
def find(p, s):
    y=[x for x in s if p(x)]
    if len(y) == 0:
        return None
    else:
        return y[0]

print("Test find")
s = set([0, 1, 2, 3, 5, -3, 1, 7, 4, 10])
print(find(p, s))
s = set([0, 2, 4,4])
print(find(p, s))


# set x from E, xRy if y reachable with one step, rel(x) = [y for y in E ]
'''
Relation function
'''
def near(x):
    return {x for x in range(x - 2, x + 2 + 1)}

print(near(0))

'''
map function that add all the related states of a set of states
'''
def flat_map(rel, l):
    def f(l1, x2):
        return l1.union(rel(x2))

    return reduce(f, l, set([]))

print("Test flat_map")
print(flat_map(near, set([0, 5])))
print(flat_map(near, set([0, 1])))


'''
Return a function that return all the state accessible with n steps from an initial set
'''
def iter(rel, n):
    def iter_rec(rel, n, l):
        if n == 0:
            return l
        else:
            return iter_rec(rel, n - 1, flat_map(rel, l))

    return partial(iter_rec, rel, n)

print("Test iter")
f = iter(near, 1)
print(f(set([0])))
f = iter(near, 2)
print(f(set([0,100])))


'''
if destination is in the research space, return the destination
else size up of one relation the research space
'''
def solve(rel, p, x):
    def rec_solve(rel,p,s):
        y = find(p, s)
        if y is not None:
            return y
        else:
            return rec_solve(rel,p,flat_map(rel, s))

    return rec_solve(rel,p,set([x]))

print("Test solve")
print(solve(near, lambda x: x == 12, 0))

'''
Compute the relational distance from all element of l to the first element that verify p
'''
def nmaxrequired(rel,p,l,n):
    y = find(p,iter(rel,n)(l))
    if y is not None:
        return n
    else:
        return nmaxrequired(rel,p,l,n+1)

print("Test nmaxrequired")
print(nmaxrequired(near,lambda x: x == 12, set([0]),0)) # waited answer 6
print(nmaxrequired(near,lambda x: x == 12, set([12]),0))# waited answer 0
print(nmaxrequired(near,lambda x: x == 12, set([11,100]),0))# waited answer 1

'''
From current step
Find a related state with closer relational distance to destination
Choose it and start again with this state
'''
def solve_path(rel, p, x):
    nmax = nmaxrequired(rel,p,set([x]),0)

    def rec_solve_path(rel, p, x,nmax):
        if nmaxrequired(rel,p,set([x]),0) == 0:
            return [x]
        else:
            nextInitial = solve(rel, lambda y:nmaxrequired(rel,p,set([y]),0)<nmax,x)
            l = [x]
            l.extend(rec_solve_path(rel, p, nextInitial,nmax-1))
            return l

    return rec_solve_path(rel,p,x,nmax)

print("Test solve path")
print(solve_path(near, lambda x: x == 12, 0))
print(solve_path(near, lambda x: x == 12, 15))

'''
end = time.time()
sys.stdout=init
print("Time elapsed")
print(end - start)
'''
# Time elapsed 0.010000944137573242
